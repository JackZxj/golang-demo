package main

import (
	"fmt"
	"reflect"
)

func main() {
	tests := []struct {
		mat [][]int
		dst [][]int
	}{
		{[][]int{{0, 0, 0}, {0, 1, 0}, {0, 0, 0}}, [][]int{{0, 0, 0}, {0, 1, 0}, {0, 0, 0}}},
		{[][]int{{1, 1, 1}, {1, 0, 1}, {1, 1, 1}}, [][]int{{2, 1, 2}, {1, 0, 1}, {2, 1, 2}}},
		{[][]int{{0, 0, 0}, {0, 1, 0}, {1, 1, 1}}, [][]int{{0, 0, 0}, {0, 1, 0}, {1, 2, 1}}},
		{[][]int{{0, 0, 0, 1, 1, 1, 1}}, [][]int{{0, 0, 0, 1, 2, 3, 4}}},
		{[][]int{{1, 1, 1, 1, 0, 0, 0}}, [][]int{{4, 3, 2, 1, 0, 0, 0}}},
		{[][]int{{1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {0, 0, 0}}, [][]int{{3, 3, 3}, {2, 2, 2}, {1, 1, 1}, {0, 0, 0}}},
		{[][]int{{1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {1, 1, 1}, {0, 0, 0}}, [][]int{{19, 19, 19}, {18, 18, 18}, {17, 17, 17}, {16, 16, 16}, {15, 15, 15}, {14, 14, 14}, {13, 13, 13}, {12, 12, 12}, {11, 11, 11}, {10, 10, 10}, {9, 9, 9}, {8, 8, 8}, {7, 7, 7}, {6, 6, 6}, {5, 5, 5}, {4, 4, 4}, {3, 3, 3}, {2, 2, 2}, {1, 1, 1}, {0, 0, 0}}},
		{[][]int{{1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 0, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1}}, [][]int{{7, 6, 5, 4, 3, 4, 5, 6}, {6, 5, 4, 3, 2, 3, 4, 5}, {5, 4, 3, 2, 1, 2, 3, 4}, {4, 3, 2, 1, 0, 1, 2, 3}, {5, 4, 3, 2, 1, 2, 3, 4}, {6, 5, 4, 3, 2, 3, 4, 5}, {7, 6, 5, 4, 3, 4, 5, 6}, {8, 7, 6, 5, 4, 5, 6, 7}, {9, 8, 7, 6, 5, 6, 7, 8}}},
	}
	for i, test := range tests {
		got := updateMatrix(test.mat)
		if !reflect.DeepEqual(got, test.dst) {
			fmt.Printf("%d# input %+v, got: %v\n", i, test, got)
			panic("not ok")
		}
	}
	fmt.Println("ok")
}

var (
	dx = [4]int{1, 0, 0, -1}
	dy = [4]int{0, 1, -1, 0}
)

type Point struct {
	m, n, dist int
}

func updateMatrix(mat [][]int) [][]int {
	queue := make([]Point, 0)
	for i := range mat {
		for j := range mat[i] {
			if mat[i][j] == 0 {
				queue = append(queue, Point{i, j, 0})
			} else {
				mat[i][j] = -1
			}
		}
	}
	for len(queue) > 0 {
		for k := range dx {
			if 0 <= queue[0].m+dy[k] && queue[0].m+dy[k] < len(mat) &&
				0 <= queue[0].n+dx[k] && queue[0].n+dx[k] < len(mat[0]) &&
				mat[queue[0].m+dy[k]][queue[0].n+dx[k]] == -1 {
				queue = append(queue, Point{queue[0].m + dy[k], queue[0].n + dx[k], queue[0].dist + 1})
				mat[queue[0].m+dy[k]][queue[0].n+dx[k]] = queue[0].dist + 1
			}
		}
		queue = queue[1:]
	}
	return mat
}
